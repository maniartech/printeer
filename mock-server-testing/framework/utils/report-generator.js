import fs from 'fs';
import path from 'path';
import { FilenameGenerator } from './filename-generator.js';

/**
 * Test result reporting utilities
 */
export class ReportGenerator {
  constructor(config = {}) {
    this.config = {
      outputDir: './output/reports',
      includeThumbnails: false,
      generateComparisons: true,
      ...config
    };
    this.filenameGenerator = new FilenameGenerator();
  }

  /**
   * Generate comprehensive HTML report
   */
  generateHTMLReport(results) {
    const timestamp = new Date().toISOString();
    const summary = this.calculateSummary(results);
    const groupedResults = this.groupResultsByFeature(results);

    const html = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Printeer Mock Server Test Results - ${timestamp}</title>
      <style>
        ${this.getReportCSS()}
      </style>
    </head>
    <body>
      <div class="container">
        <header class="report-header">
          <h1>🧪 Printeer Mock Server Test Results</h1>
          <div class="timestamp">Generated: ${new Date().toLocaleString()}</div>
        </header>

        <div class="summary-section">
          <h2>📊 Test Summary</h2>
          <div class="summary-grid">
            <div class="stat-card ${summary.failed === 0 ? 'success' : 'failure'}">
              <div class="stat-number">${summary.total}</div>
              <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card success">
              <div class="stat-number">${summary.passed}</div>
              <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card ${summary.failed > 0 ? 'failure' : 'success'}">
              <div class="stat-number">${summary.failed}</div>
              <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card info">
              <div class="stat-number">${summary.passRate}%</div>
              <div class="stat-label">Pass Rate</div>
            </div>
            <div class="stat-card info">
              <div class="stat-number">${Math.round(summary.duration / 1000)}s</div>
              <div class="stat-label">Duration</div>
            </div>
          </div>
        </div>

        <div class="test-groups">
          ${Object.entries(groupedResults).map(([groupName, groupResults]) =>
            this.generateGroupSection(groupName, groupResults)
          ).join('')}
        </div>

        <footer class="report-footer">
          <p>Generated by Printeer Test Framework at ${timestamp}</p>
        </footer>
      </div>

      <script>
        ${this.getReportJavaScript()}
      </script>
    </body>
    </html>`;

    return html;
  }

  generateGroupSection(groupName, groupResults) {
    const groupSummary = this.calculateSummary(groupResults);

    return `
      <div class="group-section">
        <div class="group-header" onclick="toggleGroup('${groupName}')">
          <h3>📂 ${groupName} <span class="group-stats">(${groupSummary.passed}/${groupSummary.total})</span></h3>
          <span class="toggle-icon">▼</span>
        </div>
        <div id="group-${groupName}" class="group-content">
          <div class="test-grid">
            ${groupResults.map(result => this.generateTestCard(result)).join('')}
          </div>
        </div>
      </div>
    `;
  }

  generateTestCard(result) {
    const statusClass = result.success ? 'success' : 'failure';
    const statusIcon = result.success ? '✅' : '❌';
    const fileSize = result.outputSize > 0 ? `${Math.round(result.outputSize / 1024)}KB` : 'N/A';

    return `
      <div class="test-card ${statusClass}">
        <div class="test-header">
          <span class="test-status">${statusIcon}</span>
          <h4 class="test-name">${result.testCase}</h4>
        </div>
        <div class="test-details">
          <div class="detail-row">
            <span class="label">Endpoint:</span>
            <span class="value">${result.endpoint}</span>
          </div>
          <div class="detail-row">
            <span class="label">Parameters:</span>
            <span class="value">${this.formatParameters(result.parameters)}</span>
          </div>
          <div class="detail-row">
            <span class="label">Duration:</span>
            <span class="value">${result.duration}ms</span>
          </div>
          <div class="detail-row">
            <span class="label">Output:</span>
            <span class="value">
              ${result.outputExists ?
                `<a href="${result.outputFile}" target="_blank">${path.basename(result.outputFile)}</a> (${fileSize})` :
                'No output generated'
              }
            </span>
          </div>
          ${!result.success ? `
            <div class="detail-row error">
              <span class="label">Error:</span>
              <span class="value">${result.stderr || 'Unknown error'}</span>
            </div>
          ` : ''}
        </div>
        <div class="test-command">
          <details>
            <summary>Command</summary>
            <code>${result.command}</code>
          </details>
        </div>
      </div>
    `;
  }

  /**
   * Generate JSON report for programmatic analysis
   */
  generateJSONReport(results) {
    const summary = this.calculateSummary(results);
    const groupedResults = this.groupResultsByFeature(results);

    return JSON.stringify({
      timestamp: new Date().toISOString(),
      summary,
      results,
      groupedResults,
      metadata: {
        framework: 'Printeer Mock Server Testing',
        version: '1.0.0',
        totalTests: results.length
      }
    }, null, 2);
  }

  /**
   * Generate CSV report for spreadsheet analysis
   */
  generateCSVReport(results) {
    const headers = [
      'Group',
      'Test Case',
      'Endpoint',
      'Parameters',
      'Success',
      'Duration (ms)',
      'Output File',
      'Output Size (KB)',
      'Error Message',
      'Command',
      'Timestamp'
    ];

    const rows = results.map(result => [
      result.group,
      result.testCase,
      result.endpoint,
      this.formatParameters(result.parameters),
      result.success ? 'PASS' : 'FAIL',
      result.duration,
      result.outputExists ? path.basename(result.outputFile) : '',
      result.outputSize > 0 ? Math.round(result.outputSize / 1024) : 0,
      result.stderr || '',
      result.command,
      result.timestamp
    ]);

    const csvContent = [headers, ...rows]
      .map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
      .join('\n');

    return csvContent;
  }

  /**
   * Generate failed tests report
   */
  generateFailedTestsReport(results) {
    const failedTests = results.filter(r => !r.success);

    if (failedTests.length === 0) {
      return '🎉 All tests passed successfully!';
    }

    const report = `
# Failed Tests Report

Generated: ${new Date().toISOString()}
Total Failed: ${failedTests.length}

## Failed Test Details

${failedTests.map((test, index) => `
### ${index + 1}. ${test.group}/${test.testCase}

- **Endpoint:** ${test.endpoint}
- **Parameters:** ${this.formatParameters(test.parameters)}
- **Error:** ${test.stderr || 'Unknown error'}
- **Duration:** ${test.duration}ms
- **Command:** \`${test.command}\`
- **Timestamp:** ${test.timestamp}

---
`).join('')}

## Recommendations

${this.generateFailureRecommendations(failedTests)}
    `.trim();

    return report;
  }

  /**
   * Save all report formats
   */
  async saveReports(results) {
    const reportDir = this.config.outputDir;
    fs.mkdirSync(reportDir, { recursive: true });

    const reports = {};

    // HTML Report
    const htmlContent = this.generateHTMLReport(results);
    const htmlFilename = this.filenameGenerator.generateReportFilename('summary', 'html');
    const htmlPath = path.join(reportDir, htmlFilename);
    fs.writeFileSync(htmlPath, htmlContent);
    reports.html = htmlPath;

    // JSON Report
    const jsonContent = this.generateJSONReport(results);
    const jsonFilename = this.filenameGenerator.generateReportFilename('detailed', 'json');
    const jsonPath = path.join(reportDir, jsonFilename);
    fs.writeFileSync(jsonPath, jsonContent);
    reports.json = jsonPath;

    // CSV Report
    const csvContent = this.generateCSVReport(results);
    const csvFilename = this.filenameGenerator.generateReportFilename('data', 'csv');
    const csvPath = path.join(reportDir, csvFilename);
    fs.writeFileSync(csvPath, csvContent);
    reports.csv = csvPath;

    // Failed Tests Report (if any failures)
    const failedTests = results.filter(r => !r.success);
    if (failedTests.length > 0) {
      const failedContent = this.generateFailedTestsReport(results);
      const failedFilename = this.filenameGenerator.generateReportFilename('failed-tests', 'md');
      const failedPath = path.join(reportDir, failedFilename);
      fs.writeFileSync(failedPath, failedContent);
      reports.failed = failedPath;
    }

    return reports;
  }

  // Utility methods
  calculateSummary(results) {
    const total = results.length;
    const passed = results.filter(r => r.success).length;
    const failed = total - passed;
    const totalDuration = results.reduce((sum, r) => sum + r.duration, 0);

    return {
      total,
      passed,
      failed,
      passRate: total > 0 ? Math.round((passed / total) * 100) : 0,
      duration: totalDuration
    };
  }

  groupResultsByFeature(results) {
    return results.reduce((groups, result) => {
      const group = result.group || 'unknown';
      if (!groups[group]) groups[group] = [];
      groups[group].push(result);
      return groups;
    }, {});
  }

  formatParameters(parameters) {
    if (!parameters || Object.keys(parameters).length === 0) {
      return 'default';
    }

    return Object.entries(parameters)
      .map(([k, v]) => `${k}=${v}`)
      .join(', ');
  }

  generateFailureRecommendations(failedTests) {
    const recommendations = [];

    // Check for common failure patterns
    const timeoutFailures = failedTests.filter(t => t.stderr?.includes('timeout'));
    const authFailures = failedTests.filter(t => t.stderr?.includes('auth') || t.stderr?.includes('401'));
    const networkFailures = failedTests.filter(t => t.stderr?.includes('network') || t.stderr?.includes('connection'));

    if (timeoutFailures.length > 0) {
      recommendations.push('- Consider increasing timeout values for slow-loading pages');
    }

    if (authFailures.length > 0) {
      recommendations.push('- Verify authentication credentials and headers');
    }

    if (networkFailures.length > 0) {
      recommendations.push('- Check mock server availability and network connectivity');
    }

    if (recommendations.length === 0) {
      recommendations.push('- Review individual test error messages for specific issues');
      recommendations.push('- Verify mock server endpoints are responding correctly');
      recommendations.push('- Check Printeer CLI configuration and parameters');
    }

    return recommendations.join('\n');
  }

  getReportCSS() {
    return `
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; }
      .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
      .report-header { text-align: center; margin-bottom: 30px; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .report-header h1 { color: #2563eb; margin-bottom: 10px; }
      .timestamp { color: #666; font-size: 14px; }
      .summary-section { margin-bottom: 30px; }
      .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px; }
      .stat-card { background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .stat-card.success { border-left: 4px solid #10b981; }
      .stat-card.failure { border-left: 4px solid #ef4444; }
      .stat-card.info { border-left: 4px solid #3b82f6; }
      .stat-number { font-size: 2em; font-weight: bold; margin-bottom: 5px; }
      .stat-label { color: #666; font-size: 14px; }
      .group-section { background: white; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .group-header { padding: 20px; border-bottom: 1px solid #e5e7eb; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
      .group-header:hover { background: #f9fafb; }
      .group-stats { color: #666; font-size: 14px; }
      .toggle-icon { transition: transform 0.3s; }
      .group-content { padding: 20px; }
      .test-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
      .test-card { border: 1px solid #e5e7eb; border-radius: 6px; padding: 15px; }
      .test-card.success { border-left: 4px solid #10b981; background: #f0fdfa; }
      .test-card.failure { border-left: 4px solid #ef4444; background: #fef2f2; }
      .test-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
      .test-status { font-size: 1.2em; }
      .test-name { margin: 0; }
      .test-details { margin-bottom: 10px; }
      .detail-row { display: flex; margin-bottom: 5px; font-size: 14px; }
      .detail-row.error { color: #dc2626; }
      .label { font-weight: 600; min-width: 80px; }
      .value { flex: 1; }
      .test-command { font-size: 12px; }
      .test-command code { background: #f3f4f6; padding: 5px; border-radius: 3px; display: block; overflow-x: auto; }
      .report-footer { text-align: center; margin-top: 40px; padding: 20px; color: #666; font-size: 14px; }
      a { color: #2563eb; text-decoration: none; }
      a:hover { text-decoration: underline; }
      details { cursor: pointer; }
      summary { font-weight: 600; }
    `;
  }

  getReportJavaScript() {
    return `
      function toggleGroup(groupName) {
        const content = document.getElementById('group-' + groupName);
        const icon = document.querySelector('[onclick="toggleGroup(\\'' + groupName + '\\')"] .toggle-icon');

        if (content.style.display === 'none') {
          content.style.display = 'block';
          icon.style.transform = 'rotate(0deg)';
        } else {
          content.style.display = 'none';
          icon.style.transform = 'rotate(-90deg)';
        }
      }

      // Initialize all groups as expanded
      document.addEventListener('DOMContentLoaded', function() {
        const groups = document.querySelectorAll('.group-content');
        groups.forEach(group => {
          group.style.display = 'block';
        });
      });
    `;
  }
}